\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx,times}
\usepackage{url,paralist,xspace,textcomp,fullpage}

\newcommand{\west}{\ensuremath{\textbf{West}}\xspace}
\newcommand{\east}{\ensuremath{\textbf{East}}\xspace}
\newcommand{\south}{\ensuremath{\textbf{South}}\xspace}
\newcommand{\north}{\ensuremath{\textbf{North}}\xspace}
\newcommand{\length}{\ensuremath{\textbf{length}}\xspace}
\newcommand{\el}{\ensuremath{\textbf{`elem`}}\xspace}
\newcommand{\suc}{\textbf{\ttfamily succ}\xspace}
\newcommand{\prd}{\textbf{\ttfamily pred}\xspace}

\newcommand{\src}[1]{\texttt{#1}\xspace}
\newcommand{\func}[1]{\textbf{\ttfamily #1}\xspace}
\newcommand{\functype}[2]{\mbox{\texttt{\scriptsize\textbf{#1} ::\ #2}}\xspace}

\title{Advanced Programming\\
Assignment 1: Navigating the Maze}
\author{Thomas Bracht Laumann Jespersen\\ \url{ntl316@alumni.ku.dk} \and Marco Eilers\\ \url{dbk726@alumni.ku.dk} }


\usepackage{listings}
\lstset{basicstyle=\ttfamily\scriptsize}


\begin{document}
\maketitle


\section{Explanation of the code}
The module \src{World} contains all functions and types only concerning the maze, i.e. directions, positions and functions for manipulating them, as well as the testMaze specified in the assignment. 

\src{MEL.hs} contains all types and functions concerning the interpreter and \src{Test.hs} contains several kinds of unit- and integration tests concerning both the maze and the MEL interpreter.

\subsection{Making sense of cardinal directions in \func{Enum}}
\func{Enum} was originally indicated to be derived automatically for \func{Direction}, but it wasn't really useful since the standard derivation doesn't facilitate wraparound when using \suc and \prd. Ideally, we would like \suc to be a 90\textdegree\ turn to either left or right, such that for instance for instance, $\text{\suc\ }\west = \north$. In order to this we need to implement the functions \functype{fromEnum}{Direction -> Int} and \functype{toEnum}{Int -> Direction}.

\func{toEnum} is straightforward to implement, we just need to arrange the order of the directions, meaning that translating \north to 0, \east should be 1 and so forth. To implement \func{toEnum} it's useful to think of how \func{Enum} works. We have the following equivalence:
\[
\text{\suc\ } \west\quad\equiv\quad\text{\func{toEnum} } ((\text{\func{fromEnum} } \west) + 1),
\]
meaning that in our case, 4 should be equivalent to \north. It is implemented in the following way:
\begin{lstlisting}[language=haskell]
  toEnum n = [North, East, South, West] !! (n `mod` 4)
\end{lstlisting}
meaning that for a given direction $d\in\{\north,\east,\south,\west \}$
\[
\text{let: } k = \text{\func{fromEnum} } d\quad\text{then}\quad\text{\func{toEnum} } k + 4i = d,\;\forall i\in\mathbb{Z}.
\]

\subsection{The Maze}
Our type for the maze is as follows:
\begin{lstlisting}[language=haskell]
data Maze = Maze { width  :: Int
                 , height :: Int
                 , cells  :: M.Map Position Cell
                 } deriving (Show)
\end{lstlisting}


We assume that the maze fulfills the following constraints:  

\begin{itemize}
  \item It must not be possible to leave the maze:
    \begin{itemize}\setlength{\itemsep}{-2pt}
      \item \verb|West `elem` cells| must be \texttt{True} for all positions \makebox{$(0, n)$, $0\leq n < \mathtt{height}$}
      \item \verb|North `elem` cells| must be \texttt{True} for all positions \makebox{$(n, \mathtt{height}-1)$, $0\leq n < \mathtt{width}$}
      \item \verb|East `elem` cells| must be \texttt{True} for all positions \makebox{$(\mathtt{width}-1, n)$, $0\leq n < \mathtt{height}$}
      \item \verb|West `elem` cells| must be \texttt{True} for all positions \makebox{$(n, 0)$, $0\leq n < \mathtt{width}$}
    \end{itemize}
  \item \east \el cells ! $(x, y)$ $\Leftrightarrow$ \west \el cells ! $(x+1, y)$ - One can only go from a to b if of can also go from b to a
  \item \north \el cells ! $(x, y)$ $\Leftrightarrow$\south \el cells ! $(x+1, y)$
  \item (Just c) = lookup cells $(x,y)$ - Every cell within the specified boundaries must be defined
\end{itemize}
When creating a new maze through the function \textbf{fromList}, the function \textbf{check} is called to make sure all these constraints are fulfilled; otherwise an error is raised.

For the type RobotCommand, we chose the following format:
\begin{verbatim}
newtype RobotCommand a = RC { runRC :: (Maze, Robot) -> Either Robot (a, Robot) }
\end{verbatim}
A RobotCommand takes in a World, consisting of a Maze and a Robot. If the command is completed succesfully (the Right case), it returns a pair of (a, Robot); if there is an error during the execution, it returns a Robot, so that the position where the error has occured and the robot's history up until that point can be retrieved. We only return a Robot (instead of a whole World) to reflect the fact that the Maze cannot be changed through command execution.

In order to make this type a monadic instance, we created two functions:

\begin{lstlisting}[language=haskell]
inject :: a -> RobotCommand a
inject a = RC $ \(_,r) -> Right (a,r)
 
chain :: RobotCommand a -> (a -> RobotCommand b) -> RobotCommand b
chain (RC h) f = RC $ \w@(m,r) -> do (a, r') <- h w
                                     let (RC g) = f a
                                     g (m, r')
                                     
instance Monad RobotCommand where
  return = inject
  (>>=)  = chain
\end{lstlisting}
The \textbf{chain} function, which we use to define our bind operator, appends one RobotCommand to another one by first running the first command on the input, and then running the second one on the state resulting from the first command. Note that, since the maze does not change and is not returned by the first RC, we run the second RC on a world consisting of our original maze and the robot returned by the first command.

Note that we use \textbf{do}-Syntax in the definition of our monad, which uses the \textbf{Either} monad and does the error handling for us.

The function \textbf{interp}, as specified in the assignment, turns a statement into a RobotCommand. The implementations for moving or changing direction simply manipulate the position and the direction of the input Robot. \textbf{evalCond} evaluates for all conditions if they are true in the given world. 

The implementations for While and Block commands might be of interest: The first evaluates the given condition and, if the condition is satisfied, executes a new block containing the loop body and the while statement itself; otherwise it just returns the current Robot. Similarly, the Block command executes the first statement in the block and then executes a new Block command containing the remaining block statements.




\section{Assessment}

\end{document}
