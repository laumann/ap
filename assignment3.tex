\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{url,paralist,xspace,textcomp}
\usepackage{enumitem}
\usepackage{fullpage}

%% First argument is name of Prolog function, second argument is number of args
\newcommand{\pfunc}[1]{\textnormal{\texttt{#1}}\xspace}
\newcommand{\pfuncn}[2]{\textnormal{\texttt{#1/#2}}\xspace}

\newcommand{\plVar}[1]{\texttt{#1}\xspace}
\newcommand{\code}[1]{\texttt{\scriptsize #1}}

\title{Advanced Programming\\ Assignment 3: Remember that song?}
\author{Thomas Bracht Laumann Jespersen\\ \url{ntl316@alumni.ku.dk} \and Marco Eilers\\ \url{dbk726@alumni.ku.dk} }

\usepackage{listings}
\lstset{basicstyle=\ttfamily\scriptsize}


\begin{document}
\maketitle

The code is split up into three modules: The module \texttt{mr}
 contains the general purpose Map-Reduce skeleton, \texttt{mr\_wc} contains functions for working with the MXM dataset
 (using said skeleton) and \texttt{mr\_test} contains
  unit tests for both of the aforementioned modules. The file \texttt{read\_mxm.erl} contains the provided code for reading the dataset, and we expect the file \texttt{mxm\_dataset\_test.txt} to be in the current folder.

\section*{Code description}
We have implemented or completed the following functionality:
\begin{enumerate}
\item Map-Reduce skeleton
\item Total number of words in songs:
\item Compute averages:
\item Grep:
\item Reverse index:
\end{enumerate}

\section*{Assessment}
As far as we could determine, our code fulfills the specification and does what we intended it to do. Since the requirements specifically state that error handling is not part of the assignment, we mostly just assume that there will be no errors; specifically, that our mapper processes do not die and that all functions are only used on valid data.

We have used EUnit to implement unit tests for both the general MR skeleton and the MXM functions, all of which succeed. Particularly, we make sure that
\begin{itemize}
  \item the MR skeleton starts and stops coordinator, mapper and reducer threads when we tell it to do so
  \item the MR skeleton returns correct results for several basic map and reduce functions on simple data sets
  \item the functions working on the MXM data set return correct results
  \item all of the above also work for special cases like empty data sets.
\end{itemize}
For more information on the specific tests, see \texttt{mr\_test.erl}.

Our MR skeleton is comparatively verbose, which is why we can easily observe any changes in state during the program execution and make sure whatever happens conforms to what we expected. We have used \texttt{whatwasitcalled} to monitor processes during execution for the same reason. There is also an additional command that allows to get additional status information from the coordinator.

There is actually some very basic error handling/prevention functionality in the sense that we check a few very important inputs for their validity (for example, it is not possible to start the coordinator without starting at least one mapper) and we time out instead of waiting infinitely in the reducer in case some results from the mappers go missing.

All in all, we are confident that our implementation does what we want it to do, and does so in a relatively sensible way.

\section*{Extensions}

\end{document}
